var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Gain } from "../../core/context/Gain";
import { connect, ToneAudioNode } from "../../core/context/ToneAudioNode";
import { optionsFromArguments } from "../../core/util/Defaults";
import { readOnly } from "../../core/util/Interface";
import { GainToAudio } from "../../signal/GainToAudio";
import { Signal } from "../../signal/Signal";
/**
 * Tone.Crossfade provides equal power fading between two inputs.
 * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).
 * ```
 *                                             +---------+
 *                                            +> input a +>--+
 * +-----------+   +---------------------+     |         |   |
 * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |
 * +-----------+   |                     |     +---------+   |
 *               +-> pan               R +>-+                |   +--------+
 *               | +---------------------+  |                +---> output +>
 *  +------+     |                          |  +---------+   |   +--------+
 *  | fade +>----+                          | +> input b +>--+
 *  +------+                                |  |         |
 *                                          +--> gain    |
 *                                             +---------+
 * ```
 * @example
 * var crossFade = new CrossFade(0.5);
 * //connect effect A to crossfade from
 * //effect output 0 to crossfade input 0
 * effectA.connect(crossFade.a);
 * //connect effect B to crossfade from
 * //effect output 0 to crossfade input 1
 * effectB.connect(crossFade.b);
 * crossFade.fade.value = 0;
 * // ^ only effectA is output
 * crossFade.fade.value = 1;
 * // ^ only effectB is output
 * crossFade.fade.value = 0.5;
 * // ^ the two signals are mixed equally.
 */
var CrossFade = /** @class */ (function (_super) {
    __extends(CrossFade, _super);
    function CrossFade() {
        var _this = _super.call(this, Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"]))) || this;
        _this.name = "CrossFade";
        /**
         * The crossfading is done by a StereoPannerNode
         */
        _this._panner = _this.context.createStereoPanner();
        /**
         * Split the output of the panner node into two values used to control the gains.
         */
        _this._split = _this.context.createChannelSplitter(2);
        /**
         * Convert the fade value into an audio range value so it can be connected
         * to the panner.pan AudioParam
         */
        _this._g2a = new GainToAudio({ context: _this.context });
        /**
         * The input which is at full level when fade = 0
         */
        _this.a = new Gain({
            context: _this.context,
            gain: 0,
        });
        /**
         * The input which is at full level when fade = 1
         */
        _this.b = new Gain({
            context: _this.context,
            gain: 0,
        });
        /**
         * The output is a mix between `a` and `b` at the ratio of `fade`
         */
        _this.output = new Gain({ context: _this.context });
        _this._internalChannels = [_this.a, _this.b];
        var options = optionsFromArguments(CrossFade.getDefaults(), arguments, ["fade"]);
        _this.fade = new Signal({
            context: _this.context,
            units: "normalRange",
            value: options.fade,
        });
        readOnly(_this, "fade");
        _this.context.getConstant(1).connect(_this._panner);
        _this._panner.connect(_this._split);
        // this is necessary for standardized-audio-context
        // doesn't make any difference for the native AudioContext
        // https://github.com/chrisguttandin/standardized-audio-context/issues/647
        _this._panner.channelCount = 1;
        _this._panner.channelCountMode = "explicit";
        connect(_this._split, _this.a.gain, 0);
        connect(_this._split, _this.b.gain, 1);
        _this.fade.chain(_this._g2a, _this._panner.pan);
        _this.a.connect(_this.output);
        _this.b.connect(_this.output);
        return _this;
    }
    CrossFade.getDefaults = function () {
        return Object.assign(ToneAudioNode.getDefaults(), {
            fade: 0.5,
        });
    };
    CrossFade.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.a.dispose();
        this.b.dispose();
        this.output.dispose();
        this.fade.dispose();
        this._g2a.dispose();
        this._panner.disconnect();
        this._split.disconnect();
        return this;
    };
    return CrossFade;
}(ToneAudioNode));
export { CrossFade };
//# sourceMappingURL=CrossFade.js.map