import { Signal, SignalOptions } from "../../signal/Signal";
import { InputNode } from "../context/ToneAudioNode";
import { BPM, Hertz, Seconds, Ticks, Time } from "../type/Units";
import { TickParam } from "./TickParam";
interface TickSignalOptions<T> extends SignalOptions<T> {
    value: T;
    multiplier: number;
}
/**
 * TickSignal extends Tone.Signal, but adds the capability
 * to calculate the number of elapsed ticks. exponential and target curves
 * are approximated with multiple linear ramps.
 *
 * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,
 * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)
 * describing integrating timing functions for tempo calculations.
 * @category Core
 */
export declare class TickSignal<Type extends Hertz | BPM> extends Signal<Type> {
    readonly name: string;
    /**
     * The param which controls the output signal value
     */
    protected _param: TickParam<Type>;
    readonly input: InputNode;
    /**
     * @param value The initial value of the signal
     */
    constructor(value?: Type);
    constructor(options: Partial<TickSignalOptions<Type>>);
    static getDefaults(): TickSignalOptions<any>;
    ticksToTime(ticks: Ticks, when: Time): Seconds;
    timeToTicks(duration: Time, when: Time): Ticks;
    getTimeOfTick(tick: Ticks): Seconds;
    getDurationOfTicks(ticks: Ticks, time: Time): Seconds;
    getTicksAtTime(time: Time): Ticks;
    /**
     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.
     */
    multiplier: number;
    dispose(): this;
}
export {};
