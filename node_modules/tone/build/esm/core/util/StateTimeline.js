var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Timeline } from "./Timeline";
/**
 *  A Timeline State. Provides the methods: `setStateAtTime("state", time)` and `getValueAtTime(time)`
 * @param initial The initial state of the StateTimeline.  Defaults to `undefined`
 * @category Core
 */
var StateTimeline = /** @class */ (function (_super) {
    __extends(StateTimeline, _super);
    function StateTimeline(initial) {
        if (initial === void 0) { initial = "stopped"; }
        var _this = _super.call(this) || this;
        _this.name = "StateTimeline";
        _this._initial = initial;
        return _this;
    }
    /**
     *  Returns the scheduled state scheduled before or at
     *  the given time.
     * @param  time  The time to query.
     * @return  The name of the state input in setStateAtTime.
     */
    StateTimeline.prototype.getValueAtTime = function (time) {
        var event = this.get(time);
        if (event !== null) {
            return event.state;
        }
        else {
            return this._initial;
        }
    };
    /**
     *  Add a state to the timeline.
     * @param  state The name of the state to set.
     * @param  time  The time to query.
     * @param options Any additional options that are needed in the timeline.
     */
    StateTimeline.prototype.setStateAtTime = function (state, time, options) {
        // all state changes need to be >= the previous state time
        // TODO throw error if time < the previous event time
        this.add(Object.assign({}, options, {
            state: state,
            time: time,
        }));
        return this;
    };
    /**
     *  Return the event before the time with the given state
     * @param  state The state to look for
     * @param  time  When to check before
     * @return  The event with the given state before the time
     */
    StateTimeline.prototype.getLastState = function (state, time) {
        // time = this.toSeconds(time);
        var index = this._search(time);
        for (var i = index; i >= 0; i--) {
            var event_1 = this._timeline[i];
            if (event_1.state === state) {
                return event_1;
            }
        }
    };
    /**
     *  Return the event after the time with the given state
     * @param  state The state to look for
     * @param  time  When to check from
     * @return  The event with the given state after the time
     */
    StateTimeline.prototype.getNextState = function (state, time) {
        // time = this.toSeconds(time);
        var index = this._search(time);
        if (index !== -1) {
            for (var i = index; i < this._timeline.length; i++) {
                var event_2 = this._timeline[i];
                if (event_2.state === state) {
                    return event_2;
                }
            }
        }
    };
    return StateTimeline;
}(Timeline));
export { StateTimeline };
//# sourceMappingURL=StateTimeline.js.map