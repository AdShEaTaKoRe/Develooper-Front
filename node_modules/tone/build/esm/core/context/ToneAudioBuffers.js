var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { Tone } from "../Tone";
import { isAudioBuffer } from "../util/AdvancedTypeCheck";
import { optionsFromArguments } from "../util/Defaults";
import { noOp } from "../util/Interface";
import { isString } from "../util/TypeCheck";
import { ToneAudioBuffer } from "./ToneAudioBuffer";
/**
 * A data structure for holding multiple buffers in a Map-like datastructure.
 *
 * @example
 * //load a whole bank of piano samples
 * var pianoSamples = new ToneAudioBuffers({
 * 	"C4" : "path/to/C4.mp3"
 * 	"C#4" : "path/to/C#4.mp3"
 * 	"D4" : "path/to/D4.mp3"
 * 	"D#4" : "path/to/D#4.mp3"
 * }, function(){
 * 	//play one of the samples when they all load
 * 	player.buffer = pianoSamples.get("C4");
 * 	player.start();
 * });
 * @example
 * //To pass in additional parameters in the second parameter
 * var buffers = new ToneAudioBuffers(urls, {
 * 	"onload" : callback,
 * 	"baseUrl" : "../path/to/audio/"
 * })
 * @category Core
 */
var ToneAudioBuffers = /** @class */ (function (_super) {
    __extends(ToneAudioBuffers, _super);
    function ToneAudioBuffers() {
        var _this = _super.call(this) || this;
        _this.name = "ToneAudioBuffers";
        /**
         *  All of the buffers
         */
        _this._buffers = new Map();
        /**
         * Keep track of the number of loaded buffers
         */
        _this._loadingCount = 0;
        var options = optionsFromArguments(ToneAudioBuffers.getDefaults(), arguments, ["urls", "onload", "baseUrl"], "urls");
        _this.baseUrl = options.baseUrl;
        var urlMap = {};
        // add each one
        Object.keys(options.urls).forEach(function (name) {
            _this._loadingCount++;
            var url = options.urls[name];
            _this.add(name, url, _this._bufferLoaded.bind(_this, options.onload));
        });
        return _this;
    }
    ToneAudioBuffers.getDefaults = function () {
        return {
            baseUrl: "",
            onerror: noOp,
            onload: noOp,
            urls: {},
        };
    };
    /**
     *  True if the buffers object has a buffer by that name.
     * @param  name  The key or index of the buffer.
     */
    ToneAudioBuffers.prototype.has = function (name) {
        return this._buffers.has(name.toString());
    };
    /**
     *  Get a buffer by name. If an array was loaded,
     *  then use the array index.
     * @param  name  The key or index of the buffer.
     */
    ToneAudioBuffers.prototype.get = function (name) {
        this.assert(this.has(name), "ToneAudioBuffers has no buffer named: " + name);
        return this._buffers.get(name.toString());
    };
    /**
     *  A buffer was loaded. decrement the counter.
     */
    ToneAudioBuffers.prototype._bufferLoaded = function (callback) {
        this._loadingCount--;
        if (this._loadingCount === 0 && callback) {
            callback();
        }
    };
    Object.defineProperty(ToneAudioBuffers.prototype, "loaded", {
        /**
         * If the buffers are loaded or not
         */
        get: function () {
            return Array.from(this._buffers).every(function (_a) {
                var _b = __read(_a, 2), name = _b[0], buffer = _b[1];
                return buffer.loaded;
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Add a buffer by name and url to the Buffers
     * @param  name      A unique name to give the buffer
     * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.
     * @param  callback  The callback to invoke when the url is loaded.
     */
    ToneAudioBuffers.prototype.add = function (name, url, callback) {
        if (callback === void 0) { callback = noOp; }
        if (url instanceof ToneAudioBuffer) {
            this._buffers.set(name.toString(), url);
            callback();
        }
        else if (isAudioBuffer(url)) {
            this._buffers.set(name.toString(), new ToneAudioBuffer(url));
            callback();
        }
        else if (isString(url)) {
            this._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback));
        }
        return this;
    };
    /**
     *  Clean up.
     */
    ToneAudioBuffers.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._buffers.forEach(function (buffer) { return buffer.dispose(); });
        this._buffers.clear();
        return this;
    };
    return ToneAudioBuffers;
}(Tone));
export { ToneAudioBuffers };
//# sourceMappingURL=ToneAudioBuffers.js.map