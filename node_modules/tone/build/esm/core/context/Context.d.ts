import { TickerClockSource } from "../clock/Ticker";
import { Seconds } from "../type/Units";
import { Emitter } from "../util/Emitter";
import { Omit } from "../util/Interface";
import { AnyAudioContext } from "./AudioContext";
declare type Transport = import("../clock/Transport").Transport;
declare type Destination = import("./Destination").Destination;
export declare type ContextLatencyHint = AudioContextLatencyCategory | "fastest";
export declare type ExcludedFromBaseAudioContext = "onstatechange" | "addEventListener" | "removeEventListener" | "listener" | "dispatchEvent" | "audioWorklet" | "destination" | "createScriptProcessor";
export declare type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;
export interface ContextOptions {
    clockSource: TickerClockSource;
    latencyHint: ContextLatencyHint;
    lookAhead: Seconds;
    updateInterval: Seconds;
    context: AnyAudioContext;
}
export interface ContextTimeoutEvent {
    callback: (...args: any[]) => void;
    id: number;
    time: Seconds;
}
/**
 * Wrapper around the native AudioContext.
 * @category Core
 */
export declare class Context extends Emitter<"statechange" | "tick"> implements BaseAudioContextSubset {
    readonly name: string;
    /**
     * The amount of time into the future events are scheduled. Giving Web Audio
     * a short amount of time into the future to schedule events can reduce clicks and
     * improve performance. This value can be set to 0 to get the lowest latency.
     */
    lookAhead: Seconds;
    /**
     * private reference to the BaseAudioContext
     */
    protected readonly _context: AnyAudioContext;
    /**
     * A reliable callback method
     */
    private readonly _ticker;
    /**
     *  The default latency hint
     */
    private _latencyHint;
    /**
     *  An object containing all of the constants AudioBufferSourceNodes
     */
    private _constants;
    /**
     *  All of the setTimeout events.
     */
    private _timeouts;
    /**
     *  The timeout id counter
     */
    private _timeoutIds;
    /**
     * A reference the Transport singleton belonging to this context
     */
    private _transport;
    /**
     * A reference the Destination singleton belonging to this context
     */
    private _destination;
    /**
     * Private indicator if the context has been initialized
     */
    private _initialized;
    constructor(context?: AnyAudioContext);
    constructor(options?: Partial<ContextOptions>);
    static getDefaults(): ContextOptions;
    /**
     * Finish setting up the context. **You usually do not need to do this manually.**
     */
    initialize(): this;
    createAnalyser(): AnalyserNode;
    createOscillator(): OscillatorNode;
    createBufferSource(): AudioBufferSourceNode;
    createBiquadFilter(): BiquadFilterNode;
    createBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer;
    createChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode;
    createChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode;
    createConstantSource(): ConstantSourceNode;
    createConvolver(): ConvolverNode;
    createDelay(maxDelayTime?: number | undefined): DelayNode;
    createDynamicsCompressor(): DynamicsCompressorNode;
    createGain(): GainNode;
    createIIRFilter(feedForward: number[], feedback: number[]): IIRFilterNode;
    createPanner(): PannerNode;
    createPeriodicWave(real: number[] | Float32Array, imag: number[] | Float32Array, constraints?: PeriodicWaveConstraints | undefined): PeriodicWave;
    createStereoPanner(): StereoPannerNode;
    createWaveShaper(): WaveShaperNode;
    decodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer>;
    /**
     *  The current time in seconds of the AudioContext.
     */
    readonly currentTime: Seconds;
    /**
     *  The current time in seconds of the AudioContext.
     */
    readonly state: AudioContextState;
    /**
     *  The current time in seconds of the AudioContext.
     */
    readonly sampleRate: number;
    /**
     *  The listener
     */
    readonly listener: AudioListener;
    /**
     *  There is only one Transport per Context. It is created on initialization.
     */
    transport: Transport;
    /**
     *  A reference to the Context's destination node.
     */
    destination: Destination;
    /**
     *  How often the interval callback is invoked.
     *  This number corresponds to how responsive the scheduling
     *  can be. context.updateInterval + context.lookAhead gives you the
     *  total latency between scheduling an event and hearing it.
     */
    updateInterval: Seconds;
    /**
     *  What the source of the clock is, either "worker" (default),
     *  "timeout", or "offline" (none).
     */
    clockSource: TickerClockSource;
    /**
     * The type of playback, which affects tradeoffs between audio
     * output latency and responsiveness.
     * In addition to setting the value in seconds, the latencyHint also
     * accepts the strings "interactive" (prioritizes low latency),
     * "playback" (prioritizes sustained playback), "balanced" (balances
     * latency and performance), and "fastest" (lowest latency, might glitch more often).
     * @example
     * //set the lookAhead to 0.3 seconds
     * Tone.context.latencyHint = 0.3;
     */
    latencyHint: ContextLatencyHint | Seconds;
    /**
     *  The unwrapped AudioContext.
     */
    readonly rawContext: AnyAudioContext;
    /**
     * The current audio context time plus a short {@link lookAhead}.
     */
    now(): Seconds;
    /**
     *  Starts the audio context from a suspended state. This is required
     *  to initially start the AudioContext.
     */
    resume(): Promise<void>;
    /**
     *  Promise which is invoked when the context is running.
     *  Tries to resume the context if it's not started.
     */
    close(): Promise<void>;
    /**
     *  Generate a looped buffer at some constant value.
     */
    getConstant(val: number): AudioBufferSourceNode;
    /**
     *  Clean up. Also closes the audio context.
     */
    dispose(): this;
    /**
     *  The private loop which keeps track of the context scheduled timeouts
     *  Is invoked from the clock source
     */
    private _timeoutLoop;
    /**
     *  A setTimeout which is guaranteed by the clock source.
     *  Also runs in the offline context.
     * @param  fn       The callback to invoke
     * @param  timeout  The timeout in seconds
     * @returns ID to use when invoking Context.clearTimeout
     */
    setTimeout(fn: (...args: any[]) => void, timeout: Seconds): number;
    /**
     *  Clears a previously scheduled timeout with Tone.context.setTimeout
     * @param  id  The ID returned from setTimeout
     */
    clearTimeout(id: number): this;
    /**
     * Clear the function scheduled by [[setInterval]]
     */
    clearInterval(id: number): this;
    /**
     * Adds a repeating event to the context's callback clock
     */
    setInterval(fn: (...args: any[]) => void, interval: Seconds): number;
}
export {};
