var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { Ticker } from "../clock/Ticker";
import { isAudioContext } from "../util/AdvancedTypeCheck";
import { optionsFromArguments } from "../util/Defaults";
import { Emitter } from "../util/Emitter";
import { Timeline } from "../util/Timeline";
import { isString } from "../util/TypeCheck";
import { getAudioContext } from "./AudioContext";
import { closeContext, initializeContext } from "./ContextInitialization";
/**
 * Wrapper around the native AudioContext.
 * @category Core
 */
var Context = /** @class */ (function (_super) {
    __extends(Context, _super);
    function Context() {
        var _this = _super.call(this) || this;
        _this.name = "Context";
        /**
         *  An object containing all of the constants AudioBufferSourceNodes
         */
        _this._constants = new Map();
        /**
         *  All of the setTimeout events.
         */
        _this._timeouts = new Timeline();
        /**
         *  The timeout id counter
         */
        _this._timeoutIds = 0;
        /**
         * Private indicator if the context has been initialized
         */
        _this._initialized = false;
        var options = optionsFromArguments(Context.getDefaults(), arguments, ["context"]);
        _this._context = options.context;
        _this._latencyHint = options.latencyHint;
        _this.lookAhead = options.lookAhead;
        _this._ticker = new Ticker(_this.emit.bind(_this, "tick"), options.clockSource, options.updateInterval);
        _this.on("tick", _this._timeoutLoop.bind(_this));
        // fwd events from the context
        _this._context.onstatechange = function () {
            _this.emit("statechange", _this.state);
        };
        return _this;
    }
    Context.getDefaults = function () {
        return {
            clockSource: "worker",
            context: getAudioContext(),
            latencyHint: "interactive",
            lookAhead: 0.1,
            updateInterval: 0.03,
        };
    };
    /**
     * Finish setting up the context. **You usually do not need to do this manually.**
     */
    Context.prototype.initialize = function () {
        if (!this._initialized) {
            // add any additional modules
            initializeContext(this);
            this._initialized = true;
        }
        return this;
    };
    ///////////////////////////////////////////////////////////////////////
    // BASE AUDIO CONTEXT METHODS
    ///////////////////////////////////////////////////////////////////////
    Context.prototype.createAnalyser = function () {
        return this._context.createAnalyser();
    };
    Context.prototype.createOscillator = function () {
        return this._context.createOscillator();
    };
    Context.prototype.createBufferSource = function () {
        return this._context.createBufferSource();
    };
    Context.prototype.createBiquadFilter = function () {
        return this._context.createBiquadFilter();
    };
    Context.prototype.createBuffer = function (numberOfChannels, length, sampleRate) {
        return this._context.createBuffer(numberOfChannels, length, sampleRate);
    };
    Context.prototype.createChannelMerger = function (numberOfInputs) {
        return this._context.createChannelMerger(numberOfInputs);
    };
    Context.prototype.createChannelSplitter = function (numberOfOutputs) {
        return this._context.createChannelSplitter(numberOfOutputs);
    };
    Context.prototype.createConstantSource = function () {
        return this._context.createConstantSource();
    };
    Context.prototype.createConvolver = function () {
        return this._context.createConvolver();
    };
    Context.prototype.createDelay = function (maxDelayTime) {
        return this._context.createDelay(maxDelayTime);
    };
    Context.prototype.createDynamicsCompressor = function () {
        return this._context.createDynamicsCompressor();
    };
    Context.prototype.createGain = function () {
        return this._context.createGain();
    };
    Context.prototype.createIIRFilter = function (feedForward, feedback) {
        return this._context.createIIRFilter(feedForward, feedback);
    };
    Context.prototype.createPanner = function () {
        return this._context.createPanner();
    };
    Context.prototype.createPeriodicWave = function (real, imag, constraints) {
        return this._context.createPeriodicWave(real, imag, constraints);
    };
    Context.prototype.createStereoPanner = function () {
        return this._context.createStereoPanner();
    };
    Context.prototype.createWaveShaper = function () {
        return this._context.createWaveShaper();
    };
    Context.prototype.decodeAudioData = function (audioData) {
        return this._context.decodeAudioData(audioData);
    };
    Object.defineProperty(Context.prototype, "currentTime", {
        /**
         *  The current time in seconds of the AudioContext.
         */
        get: function () {
            return this._context.currentTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "state", {
        /**
         *  The current time in seconds of the AudioContext.
         */
        get: function () {
            return this._context.state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "sampleRate", {
        /**
         *  The current time in seconds of the AudioContext.
         */
        get: function () {
            return this._context.sampleRate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "listener", {
        /**
         *  The listener
         */
        get: function () {
            return this._context.listener;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "transport", {
        /**
         *  There is only one Transport per Context. It is created on initialization.
         */
        get: function () {
            this.assert(this._initialized, "The context must be initialized before being used by invoking context.initialize()");
            return this._transport;
        },
        set: function (t) {
            this.assert(!this._initialized, "The transport cannot be set after initialization.");
            this._transport = t;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "destination", {
        /**
         *  A reference to the Context's destination node.
         */
        get: function () {
            this.assert(this._initialized, "The context must be initialized before being used by invoking context.initialize()");
            return this._destination;
        },
        set: function (d) {
            this.assert(!this._initialized, "The transport cannot be set after initialization.");
            this._destination = d;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "updateInterval", {
        ///////////////////////////////////////////////////////////////////////
        // TICKER
        ///////////////////////////////////////////////////////////////////////
        /**
         *  How often the interval callback is invoked.
         *  This number corresponds to how responsive the scheduling
         *  can be. context.updateInterval + context.lookAhead gives you the
         *  total latency between scheduling an event and hearing it.
         */
        get: function () {
            return this._ticker.updateInterval;
        },
        set: function (interval) {
            this._ticker.updateInterval = interval;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "clockSource", {
        /**
         *  What the source of the clock is, either "worker" (default),
         *  "timeout", or "offline" (none).
         */
        get: function () {
            return this._ticker.type;
        },
        set: function (type) {
            this._ticker.type = type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "latencyHint", {
        /**
         * The type of playback, which affects tradeoffs between audio
         * output latency and responsiveness.
         * In addition to setting the value in seconds, the latencyHint also
         * accepts the strings "interactive" (prioritizes low latency),
         * "playback" (prioritizes sustained playback), "balanced" (balances
         * latency and performance), and "fastest" (lowest latency, might glitch more often).
         * @example
         * //set the lookAhead to 0.3 seconds
         * Tone.context.latencyHint = 0.3;
         */
        get: function () {
            return this._latencyHint;
        },
        set: function (hint) {
            var lookAheadValue = 0;
            this._latencyHint = hint;
            if (isString(hint)) {
                switch (hint) {
                    case "interactive":
                        lookAheadValue = 0.1;
                        break;
                    case "playback":
                        lookAheadValue = 0.8;
                        break;
                    case "balanced":
                        lookAheadValue = 0.25;
                        break;
                    case "fastest":
                        lookAheadValue = 0.01;
                        break;
                }
            }
            this.lookAhead = lookAheadValue;
            this.updateInterval = lookAheadValue / 3;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "rawContext", {
        /**
         *  The unwrapped AudioContext.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The current audio context time plus a short {@link lookAhead}.
     */
    Context.prototype.now = function () {
        return this._context.currentTime + this.lookAhead;
    };
    /**
     *  Starts the audio context from a suspended state. This is required
     *  to initially start the AudioContext.
     */
    Context.prototype.resume = function () {
        if (this._context.state === "suspended" && isAudioContext(this._context)) {
            return this._context.resume();
        }
        else {
            return Promise.resolve();
        }
    };
    /**
     *  Promise which is invoked when the context is running.
     *  Tries to resume the context if it's not started.
     */
    Context.prototype.close = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!isAudioContext(this._context)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._context.close()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (this._initialized) {
                            closeContext(this);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     *  Generate a looped buffer at some constant value.
     */
    Context.prototype.getConstant = function (val) {
        if (this._constants.has(val)) {
            return this._constants.get(val);
        }
        else {
            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);
            var arr = buffer.getChannelData(0);
            for (var i = 0; i < arr.length; i++) {
                arr[i] = val;
            }
            var constant = this._context.createBufferSource();
            constant.channelCount = 1;
            constant.channelCountMode = "explicit";
            constant.buffer = buffer;
            constant.loop = true;
            constant.start(0);
            this._constants.set(val, constant);
            return constant;
        }
    };
    /**
     *  Clean up. Also closes the audio context.
     */
    Context.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this._ticker.dispose();
        this._timeouts.dispose();
        Object.keys(this._constants).map(function (val) { return _this._constants[val].disconnect(); });
        return this;
    };
    ///////////////////////////////////////////////////////////////////////
    // TIMEOUTS
    ///////////////////////////////////////////////////////////////////////
    /**
     *  The private loop which keeps track of the context scheduled timeouts
     *  Is invoked from the clock source
     */
    Context.prototype._timeoutLoop = function () {
        var now = this.now();
        var firstEvent = this._timeouts.peek();
        while (this._timeouts.length && firstEvent && firstEvent.time <= now) {
            // invoke the callback
            firstEvent.callback();
            // shift the first event off
            this._timeouts.shift();
            // get the next one
            firstEvent = this._timeouts.peek();
        }
    };
    /**
     *  A setTimeout which is guaranteed by the clock source.
     *  Also runs in the offline context.
     * @param  fn       The callback to invoke
     * @param  timeout  The timeout in seconds
     * @returns ID to use when invoking Context.clearTimeout
     */
    Context.prototype.setTimeout = function (fn, timeout) {
        this._timeoutIds++;
        var now = this.now();
        this._timeouts.add({
            callback: fn,
            id: this._timeoutIds,
            time: now + timeout,
        });
        return this._timeoutIds;
    };
    /**
     *  Clears a previously scheduled timeout with Tone.context.setTimeout
     * @param  id  The ID returned from setTimeout
     */
    Context.prototype.clearTimeout = function (id) {
        var _this = this;
        this._timeouts.forEach(function (event) {
            if (event.id === id) {
                _this._timeouts.remove(event);
            }
        });
        return this;
    };
    /**
     * Clear the function scheduled by [[setInterval]]
     */
    Context.prototype.clearInterval = function (id) {
        return this.clearTimeout(id);
    };
    /**
     * Adds a repeating event to the context's callback clock
     */
    Context.prototype.setInterval = function (fn, interval) {
        var _this = this;
        var id = ++this._timeoutIds;
        var intervalFn = function () {
            var now = _this.now();
            _this._timeouts.add({
                callback: function () {
                    // invoke the callback
                    fn();
                    // invoke the event to repeat it
                    intervalFn();
                },
                id: id,
                time: now + interval,
            });
        };
        // kick it off
        intervalFn();
        return id;
    };
    return Context;
}(Emitter));
export { Context };
//# sourceMappingURL=Context.js.map