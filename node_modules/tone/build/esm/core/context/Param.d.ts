import { AbstractParam } from "../context/AbstractParam";
import { Positive, Time, Unit, UnitName } from "../type/Units";
import { Timeline } from "../util/Timeline";
import { ToneWithContext, ToneWithContextOptions } from "./ToneWithContext";
export interface ParamOptions<Type> extends ToneWithContextOptions {
    units: UnitName;
    value?: Type;
    param: AudioParam | Param<Type>;
    convert: boolean;
}
/**
 * the possible automation types
 */
declare type AutomationType = "linearRampToValueAtTime" | "exponentialRampToValueAtTime" | "setValueAtTime" | "setTargetAtTime" | "cancelScheduledValues";
interface TargetAutomationEvent {
    type: "setTargetAtTime";
    time: number;
    value: number;
    constant: number;
}
interface NormalAutomationEvent {
    type: Exclude<AutomationType, "setTargetAtTime">;
    time: number;
    value: number;
}
/**
 * The events on the automation
 */
export declare type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;
/**
 * Param wraps the native Web Audio's AudioParam to provide
 * additional unit conversion functionality. It also
 * serves as a base-class for classes which have a single,
 * automatable parameter.
 * @category Core
 */
export declare class Param<Type extends Unit = number> extends ToneWithContext<ParamOptions<Type>> implements AbstractParam<Type> {
    readonly name: string;
    static getDefaults(): ParamOptions<any>;
    /**
     * The input connection
     */
    readonly input: AudioParam;
    readonly units: UnitName;
    convert: boolean;
    overridden: boolean;
    /**
     * The timeline which tracks all of the automations.
     */
    protected _events: Timeline<AutomationEvent>;
    /**
     *  The native parameter to control
     */
    protected _param: AudioParam;
    /**
     *  The default value before anything is assigned
     */
    protected _initialValue: number;
    /**
     *  The minimum output value
     */
    private _minOutput;
    /**
     * @param param The AudioParam to wrap
     * @param units The unit name
     * @param convert Whether or not to convert the value to the target units
     */
    constructor(param: AudioParam, units?: Unit, convert?: boolean);
    constructor(options: Partial<ParamOptions<Type>>);
    value: Type;
    readonly minValue: number;
    readonly maxValue: number;
    /**
     * Type guard based on the unit name
     */
    private _is;
    /**
     *  Convert the given value from the type specified by Param.units
     *  into the destination value (such as Gain or Frequency).
     */
    protected _fromType(val: Type): number;
    /**
     * Convert the parameters value into the units specified by Param.units.
     */
    protected _toType(val: number): Type;
    setValueAtTime(value: Type, time: Time): this;
    getValueAtTime(time: Time): Type;
    setRampPoint(time: Time): this;
    linearRampToValueAtTime(value: Type, endTime: Time): this;
    exponentialRampToValueAtTime(value: Type, endTime: Time): this;
    exponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this;
    linearRampTo(value: Type, rampTime: Time, startTime?: Time): this;
    targetRampTo(value: Type, rampTime: Time, startTime?: Time): this;
    exponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this;
    setTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this;
    setValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this;
    cancelScheduledValues(time: Time): this;
    cancelAndHoldAtTime(time: Time): this;
    rampTo(value: Type, rampTime?: Time, startTime?: Time): this;
    /**
     * Apply all of the previously scheduled events to the passed in Param or AudioParam.
     * The applied values will start at the context's current time and schedule
     * all of the events which are scheduled on this Param onto the passed in param.
     */
    apply(param: Param | AudioParam): this;
    dispose(): this;
    readonly defaultValue: Type;
    protected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number;
    protected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number;
    protected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number;
}
export {};
