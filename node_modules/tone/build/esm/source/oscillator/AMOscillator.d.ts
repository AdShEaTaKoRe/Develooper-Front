import { Cents, Degrees, Frequency, Positive, Seconds, Time } from "../../core/type/Units";
import { Signal } from "../../signal/Signal";
import { Source } from "../Source";
import { AMConstructorOptions, AMOscillatorOptions, ToneOscillatorInterface, ToneOscillatorType } from "./OscillatorInterface";
export { AMOscillatorOptions } from "./OscillatorInterface";
/**
 * An amplitude modulated oscillator node. It is implemented with
 * two oscillators, one which modulators the other's amplitude
 * through a gain node.
 * ```
 *    +-------------+       +----------+
 *    | Carrier Osc +>------> GainNode |
 *    +-------------+       |          +--->Output
 *                      +---> gain     |
 * +---------------+    |   +----------+
 * | Modulator Osc +>---+
 * +---------------+
 * ```
 *
 * @example
 * //a sine oscillator frequency-modulated by a square wave
 * var fmOsc = new AMOscillator("Ab3", "sine", "square").toDestination().start();
 */
export declare class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {
    readonly name: string;
    /**
     *  The carrier oscillator
     */
    private _carrier;
    /**
     *  The oscillator's frequency
     */
    readonly frequency: Signal<Frequency>;
    /**
     *  The detune control signal.
     */
    readonly detune: Signal<Cents>;
    /**
     *  The modulating oscillator
     */
    private _modulator;
    /**
     *  convert the -1,1 output to 0,1
     */
    private _modulationScale;
    /**
     *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.
     *  A harmonicity of 1 gives both oscillators the same frequency.
     *  Harmonicity = 2 means a change of an octave.
     * @example
     * //pitch the modulator an octave below carrier
     * synth.harmonicity.value = 0.5;
     */
    readonly harmonicity: Signal<Positive>;
    /**
     *  the node where the modulation happens
     */
    private _modulationNode;
    /**
     * @param frequency The starting frequency of the oscillator.
     * @param type The type of the carrier oscillator.
     * @param modulationType The type of the modulator oscillator.
     */
    constructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);
    constructor(options?: Partial<AMConstructorOptions>);
    static getDefaults(): AMOscillatorOptions;
    /**
     *  start the oscillator
     */
    protected _start(time: Seconds): void;
    /**
     *  stop the oscillator
     */
    protected _stop(time: Seconds): void;
    /**
     *  restart the oscillator
     */
    restart(time?: Time): this;
    /**
     * The type of the carrier oscillator
     */
    type: ToneOscillatorType;
    /**
     * The oscillator type without the partialsCount appended to the end
     * @example
     * osc.type = 'sine2'
     * osc.baseType //'sine'
     * osc.partialCount = 2
     */
    baseType: OscillatorType;
    /**
     * 'partialCount' offers an alternative way to set the number of used partials.
     * When partialCount is 0, the maximum number of partials are used when representing
     * the waveform using the periodicWave. When 'partials' is set, this value is
     * not settable, but equals the length of the partials array.
     */
    partialCount: number;
    /**
     * The type of the modulator oscillator
     */
    modulationType: ToneOscillatorType;
    /**
     * The phase of the oscillator in degrees.
     */
    phase: Degrees;
    /**
     * The partials of the carrier waveform. A partial represents
     * the amplitude at a harmonic. The first harmonic is the
     * fundamental frequency, the second is the octave and so on
     * following the harmonic series.
     * Setting this value will automatically set the type to "custom".
     * The value is an empty array when the type is not "custom".
     * @example
     * osc.partials = [1, 0.2, 0.01];
     */
    partials: number[];
    /**
     *  Clean up.
     */
    dispose(): this;
}
