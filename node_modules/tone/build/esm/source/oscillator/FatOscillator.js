var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { optionsFromArguments } from "../../core/util/Defaults";
import { noOp, readOnly } from "../../core/util/Interface";
import { Signal } from "../../signal/Signal";
import { Source } from "../Source";
import { Oscillator } from "./Oscillator";
/**
 *  FatOscillator is an array of oscillators with detune spread between the oscillators
 * @param frequency The oscillator's frequency.
 * @param type The type of the oscillator.
 * @param spread The detune spread between the oscillators.
 * @example
 * var fatOsc = new FatOscillator("Ab3", "sine", 40).toDestination().start();
 */
var FatOscillator = /** @class */ (function (_super) {
    __extends(FatOscillator, _super);
    function FatOscillator() {
        var _this = _super.call(this, optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"])) || this;
        _this.name = "FatOscillator";
        /**
         *  The array of oscillators
         */
        _this._oscillators = [];
        var options = optionsFromArguments(FatOscillator.getDefaults(), arguments, ["frequency", "type", "spread"]);
        _this.frequency = new Signal({
            context: _this.context,
            units: "frequency",
            value: options.frequency,
        });
        _this.detune = new Signal({
            context: _this.context,
            units: "cents",
            value: options.detune,
        });
        _this._spread = options.spread;
        _this._type = options.type;
        _this._phase = options.phase;
        _this._partials = options.partials;
        _this._partialCount = options.partialCount;
        // set the count initially
        _this.count = options.count;
        readOnly(_this, ["frequency", "detune"]);
        return _this;
    }
    FatOscillator.getDefaults = function () {
        return Object.assign(Oscillator.getDefaults(), {
            count: 3,
            spread: 20,
            type: "sawtooth",
        });
    };
    /**
     *  start the oscillator
     */
    FatOscillator.prototype._start = function (time) {
        time = this.toSeconds(time);
        this._forEach(function (osc) { return osc.start(time); });
    };
    /**
     *  stop the oscillator
     */
    FatOscillator.prototype._stop = function (time) {
        time = this.toSeconds(time);
        this._forEach(function (osc) { return osc.stop(time); });
    };
    /**
     *  restart the oscillator
     */
    FatOscillator.prototype.restart = function (time) {
        time = this.toSeconds(time);
        this._forEach(function (osc) { return osc.restart(time); });
        return this;
    };
    /**
     *  Iterate over all of the oscillators
     */
    FatOscillator.prototype._forEach = function (iterator) {
        for (var i = 0; i < this._oscillators.length; i++) {
            iterator(this._oscillators[i], i);
        }
    };
    Object.defineProperty(FatOscillator.prototype, "type", {
        /**
         * The type of the oscillator
         */
        get: function () {
            return this._type;
        },
        set: function (type) {
            this._type = type;
            this._forEach(function (osc) { return osc.type = type; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FatOscillator.prototype, "spread", {
        /**
         * The detune spread between the oscillators. If "count" is
         * set to 3 oscillators and the "spread" is set to 40,
         * the three oscillators would be detuned like this: [-20, 0, 20]
         * for a total detune spread of 40 cents.
         */
        get: function () {
            return this._spread;
        },
        set: function (spread) {
            this._spread = spread;
            if (this._oscillators.length > 1) {
                var start_1 = -spread / 2;
                var step_1 = spread / (this._oscillators.length - 1);
                this._forEach(function (osc, i) { return osc.detune.value = start_1 + step_1 * i; });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FatOscillator.prototype, "count", {
        /**
         * The number of detuned oscillators. Should be an integer greater than 1.
         */
        get: function () {
            return this._oscillators.length;
        },
        set: function (count) {
            var _this = this;
            count = Math.max(count, 1);
            if (this._oscillators.length !== count) {
                // dispose the previous oscillators
                this._forEach(function (osc) { return osc.dispose(); });
                this._oscillators = [];
                for (var i = 0; i < count; i++) {
                    var osc = new Oscillator({
                        context: this.context,
                        onstop: i === 0 ? function () { return _this.onstop(_this); } : noOp,
                    });
                    if (this.type === "custom") {
                        osc.partials = this._partials;
                    }
                    else {
                        osc.type = this._type;
                    }
                    osc.partialCount = this._partialCount;
                    osc.phase = this._phase + (i / count) * 360;
                    osc.volume.value = -6 - count * 1.1;
                    this.frequency.connect(osc.frequency);
                    this.detune.connect(osc.detune);
                    osc.connect(this.output);
                    this._oscillators[i] = osc;
                }
                // set the spread
                this.spread = this._spread;
                if (this.state === "started") {
                    this._forEach(function (osc) { return osc.start(); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FatOscillator.prototype, "phase", {
        /**
         * The phase of the oscillator in degrees.
         */
        get: function () {
            return this._phase;
        },
        set: function (phase) {
            this._phase = phase;
            this._forEach(function (osc) { return osc.phase = phase; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FatOscillator.prototype, "baseType", {
        /**
         * The oscillator type without the partialsCount appended to the end
         * @example
         * osc.type = 'sine2'
         * osc.baseType //'sine'
         * osc.partialCount = 2
         */
        get: function () {
            return this._oscillators[0].baseType;
        },
        set: function (baseType) {
            this._forEach(function (osc) { return osc.baseType = baseType; });
            this._type = this._oscillators[0].type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FatOscillator.prototype, "partials", {
        /**
         * The partials of the carrier waveform. A partial represents
         * the amplitude at a harmonic. The first harmonic is the
         * fundamental frequency, the second is the octave and so on
         * following the harmonic series.
         * Setting this value will automatically set the type to "custom".
         * The value is an empty array when the type is not "custom".
         * @memberOf FatOscillator#
         * @type {Array}
         * @name partials
         * @example
         * osc.partials = [1, 0.2, 0.01];
         */
        get: function () {
            return this._oscillators[0].partials;
        },
        set: function (partials) {
            this._partials = partials;
            if (partials.length) {
                this._type = "custom";
                this._forEach(function (osc) { return osc.partials = partials; });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FatOscillator.prototype, "partialCount", {
        /**
         * 'partialCount' offers an alternative way to set the number of used partials.
         * When partialCount is 0, the maximum number of partials are used when representing
         * the waveform using the periodicWave. When 'partials' is set, this value is
         * not settable, but equals the length of the partials array.
         * @memberOf FatOscillator#
         * @type {Number}
         * @name partialCount
         */
        get: function () {
            return this._oscillators[0].partialCount;
        },
        set: function (partialCount) {
            this._partialCount = partialCount;
            this._forEach(function (osc) { return osc.partialCount = partialCount; });
            this._type = this._oscillators[0].type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Clean up.
     */
    FatOscillator.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.frequency.dispose();
        this.detune.dispose();
        this._forEach(function (osc) { return osc.dispose(); });
        return this;
    };
    return FatOscillator;
}(Source));
export { FatOscillator };
//# sourceMappingURL=FatOscillator.js.map