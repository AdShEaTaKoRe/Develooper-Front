import { AudioRange, Cents, Degrees, Frequency, Time } from "../../core/type/Units";
import { Signal } from "../../signal/Signal";
import { Source } from "../Source";
import { ToneOscillatorConstructorOptions, ToneOscillatorInterface, ToneOscillatorOptions, ToneOscillatorType } from "./OscillatorInterface";
export { ToneOscillatorOptions, ToneOscillatorType } from "./OscillatorInterface";
/**
 *  Oscillator supports a number of features including
 *  phase rotation, multiple oscillator types (see Oscillator.type),
 *  and Transport syncing (see Oscillator.syncFrequency).
 *
 * @example
 * //make and start a 440hz sine tone
 * var osc = new Oscillator(440, "sine").toDestination().start();
 */
export declare class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {
    readonly name: string;
    /**
     *  the main oscillator
     */
    private _oscillator;
    /**
     *  The frequency control.
     */
    frequency: Signal<Frequency>;
    /**
     *  The detune control signal.
     */
    detune: Signal<Cents>;
    /**
     *  the periodic wave
     */
    private _wave?;
    /**
     *  The partials of the oscillator
     */
    private _partials;
    /**
     *  The number of partials to limit or extend the periodic wave by
     */
    private _partialCount;
    /**
     *  the phase of the oscillator between 0 - 360
     */
    private _phase;
    /**
     *  the type of the oscillator
     */
    private _type;
    /**
     * @param frequency Starting frequency
     * @param type The oscillator type. Read more about type below.
     */
    constructor(frequency?: Frequency, type?: ToneOscillatorType);
    constructor(options?: Partial<ToneOscillatorConstructorOptions>);
    static getDefaults(): ToneOscillatorOptions;
    /**
     *  start the oscillator
     */
    protected _start(time?: Time): void;
    /**
     *  stop the oscillator
     */
    protected _stop(time?: Time): void;
    /**
     * Restart the oscillator. Does not stop the oscillator, but instead
     * just cancels any scheduled 'stop' from being invoked.
     */
    restart(time?: Time): this;
    /**
     *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,
     *  will also affect the oscillators frequency.
     * @example
     * Tone.Transport.bpm.value = 120;
     * osc.frequency.value = 440;
     * //the ration between the bpm and the frequency will be maintained
     * osc.syncFrequency();
     * Tone.Transport.bpm.value = 240;
     * // the frequency of the oscillator is doubled to 880
     */
    syncFrequency(): this;
    /**
     *  Unsync the oscillator's frequency from the Transport.
     *  See Oscillator.syncFrequency
     */
    unsyncFrequency(): this;
    /**
     * Cache the periodic waves to avoid having to redo computations
     */
    private static _periodicWaveCache;
    /**
     * Get a cached periodic wave. Avoids having to recompute
     * the oscillator values when they have already been computed
     * with the same values.
     */
    private _getCachedPeriodicWave;
    /**
     * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of
     * setting the first x number of partials of the oscillator. For example: "sine4" would
     * set be the first 4 partials of the sine wave and "triangle8" would set the first
     * 8 partials of the triangle wave.
     * <br><br>
     * Uses PeriodicWave internally even for native types so that it can set the phase.
     * PeriodicWave equations are from the
     * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).
     *
     * @memberOf Oscillator#
     * @type {string}
     * @name type
     * @example
     * //set it to a square wave
     * osc.type = "square";
     * @example
     * //set the first 6 partials of a sawtooth wave
     * osc.type = "sawtooth6";
     */
    type: ToneOscillatorType;
    /**
     * The oscillator type without the partialsCount appended to the end
     * @example
     * osc.type = 'sine2'
     * osc.baseType //'sine'
     * osc.partialCount = 2
     */
    baseType: OscillatorType;
    /**
     * 'partialCount' offers an alternative way to set the number of used partials.
     * When partialCount is 0, the maximum number of partials are used when representing
     * the waveform using the periodicWave. When 'partials' is set, this value is
     * not settable, but equals the length of the partials array.
     * @example
     * osc.type = 'sine'
     * osc.partialCount = 3
     * //is equivalent to
     * osc.type = 'sine3'
     */
    partialCount: number;
    /**
     *  Get the object's attributes. Given no arguments get
     *  will return all available object properties and their corresponding
     *  values.
     */
    get(): ToneOscillatorOptions;
    /**
     * Returns the real and imaginary components based
     * on the oscillator type.
     * @returns [real: Float32Array, imaginary: Float32Array]
     */
    private _getRealImaginary;
    /**
     *  Compute the inverse FFT for a given phase.
     */
    private _inverseFFT;
    /**
     * Returns the initial value of the oscillator when stopped.
     * E.g. a "sine" oscillator with phase = 90 would return an initial value of -1.
     */
    getInitialValue(): AudioRange;
    /**
     * The partials of the waveform. A partial represents
     * the amplitude at a harmonic. The first harmonic is the
     * fundamental frequency, the second is the octave and so on
     * following the harmonic series.
     * Setting this value will automatically set the type to "custom".
     * The value is an empty array when the type is not "custom".
     * @example
     * osc.partials = [1, 0.2, 0.01];
     */
    partials: number[];
    /**
     * The phase of the oscillator in degrees.
     * @example
     * osc.phase = 180; //flips the phase of the oscillator
     */
    phase: Degrees;
    dispose(): this;
}
