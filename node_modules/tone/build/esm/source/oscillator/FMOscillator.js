var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Gain } from "../../core/context/Gain";
import { optionsFromArguments } from "../../core/util/Defaults";
import { readOnly } from "../../core/util/Interface";
import { Multiply } from "../../signal/Multiply";
import { Signal } from "../../signal/Signal";
import { Source } from "../Source";
import { Oscillator } from "./Oscillator";
/**
 * FMOscillator implements a frequency modulation synthesis
 * ```
 *                                              +-------------+
 * +---------------+        +-------------+     | Carrier Osc |
 * | Modulator Osc +>-------> GainNode    |     |             +--->Output
 * +---------------+        |             +>----> frequency   |
 *                       +--> gain        |     +-------------+
 *                       |  +-------------+
 * +-----------------+   |
 * | modulationIndex +>--+
 * +-----------------+
 * ```
 *
 * @example
 * //a sine oscillator frequency-modulated by a square wave
 * var fmOsc = new FMOscillator("Ab3", "sine", "square").toDestination().start();
 */
var FMOscillator = /** @class */ (function (_super) {
    __extends(FMOscillator, _super);
    function FMOscillator() {
        var _this = _super.call(this, optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"])) || this;
        _this.name = "FMOscillator";
        /**
         *  the node where the modulation happens
         */
        _this._modulationNode = new Gain({
            context: _this.context,
            gain: 0,
        });
        var options = optionsFromArguments(FMOscillator.getDefaults(), arguments, ["frequency", "type", "modulationType"]);
        _this._carrier = new Oscillator({
            context: _this.context,
            detune: options.detune,
            frequency: 0,
            onstop: function () { return _this.onstop(_this); },
            phase: options.phase,
            type: options.type,
        });
        _this.detune = _this._carrier.detune;
        _this.frequency = new Signal({
            context: _this.context,
            units: "frequency",
            value: options.frequency,
        });
        _this._modulator = new Oscillator({
            context: _this.context,
            phase: options.phase,
            type: options.modulationType,
        });
        _this.harmonicity = new Multiply({
            context: _this.context,
            units: "positive",
            value: options.harmonicity,
        });
        _this.modulationIndex = new Multiply({
            context: _this.context,
            units: "positive",
            value: options.modulationIndex,
        });
        // connections
        _this.frequency.connect(_this._carrier.frequency);
        _this.frequency.chain(_this.harmonicity, _this._modulator.frequency);
        _this.frequency.chain(_this.modulationIndex, _this._modulationNode);
        _this._modulator.connect(_this._modulationNode.gain);
        _this._modulationNode.connect(_this._carrier.frequency);
        _this._carrier.connect(_this.output);
        _this.detune.connect(_this._modulator.detune);
        readOnly(_this, ["modulationIndex", "frequency", "detune", "harmonicity"]);
        return _this;
    }
    FMOscillator.getDefaults = function () {
        return Object.assign(Oscillator.getDefaults(), {
            harmonicity: 1,
            modulationIndex: 2,
            modulationType: "square",
        });
    };
    /**
     *  start the oscillator
     */
    FMOscillator.prototype._start = function (time) {
        this._modulator.start(time);
        this._carrier.start(time);
    };
    /**
     *  stop the oscillator
     */
    FMOscillator.prototype._stop = function (time) {
        this._modulator.stop(time);
        this._carrier.stop(time);
    };
    /**
     *  stop and restart the oscillator
     */
    FMOscillator.prototype.restart = function (time) {
        this._modulator.restart(time);
        this._carrier.restart(time);
        return this;
    };
    Object.defineProperty(FMOscillator.prototype, "type", {
        /**
         * The type of the carrier oscillator
         */
        get: function () {
            return this._carrier.type;
        },
        set: function (type) {
            this._carrier.type = type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FMOscillator.prototype, "baseType", {
        /**
         * The oscillator type without the partialsCount appended to the end
         * @example
         * osc.type = 'sine2'
         * osc.baseType //'sine'
         * osc.partialCount = 2
         */
        get: function () {
            return this._carrier.baseType;
        },
        set: function (baseType) {
            this._carrier.baseType = baseType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FMOscillator.prototype, "partialCount", {
        /**
         * 'partialCount' offers an alternative way to set the number of used partials.
         * When partialCount is 0, the maximum number of partials are used when representing
         * the waveform using the periodicWave. When 'partials' is set, this value is
         * not settable, but equals the length of the partials array.
         */
        get: function () {
            return this._carrier.partialCount;
        },
        set: function (partialCount) {
            this._carrier.partialCount = partialCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FMOscillator.prototype, "modulationType", {
        /**
         * The type of the modulator oscillator
         */
        get: function () {
            return this._modulator.type;
        },
        set: function (type) {
            this._modulator.type = type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FMOscillator.prototype, "phase", {
        /**
         * The phase of the oscillator in degrees.
         */
        get: function () {
            return this._carrier.phase;
        },
        set: function (phase) {
            this._carrier.phase = phase;
            this._modulator.phase = phase;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FMOscillator.prototype, "partials", {
        /**
         * The partials of the carrier waveform. A partial represents
         * the amplitude at a harmonic. The first harmonic is the
         * fundamental frequency, the second is the octave and so on
         * following the harmonic series.
         * Setting this value will automatically set the type to "custom".
         * The value is an empty array when the type is not "custom".
         * @example
         * osc.partials = [1, 0.2, 0.01];
         */
        get: function () {
            return this._carrier.partials;
        },
        set: function (partials) {
            this._carrier.partials = partials;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Clean up.
     */
    FMOscillator.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.frequency.dispose();
        this.harmonicity.dispose();
        this._carrier.dispose();
        this._modulator.dispose();
        this._modulationNode.dispose();
        this.modulationIndex.dispose();
        return this;
    };
    return FMOscillator;
}(Source));
export { FMOscillator };
//# sourceMappingURL=FMOscillator.js.map