import { Cents, Degrees, Frequency, Time } from "../../core/type/Units";
import { Signal } from "../../signal/Signal";
import { Source } from "../Source";
import { FatConstructorOptions, FatOscillatorOptions, ToneOscillatorInterface, ToneOscillatorType } from "./OscillatorInterface";
export { FatOscillatorOptions } from "./OscillatorInterface";
/**
 *  FatOscillator is an array of oscillators with detune spread between the oscillators
 * @param frequency The oscillator's frequency.
 * @param type The type of the oscillator.
 * @param spread The detune spread between the oscillators.
 * @example
 * var fatOsc = new FatOscillator("Ab3", "sine", 40).toDestination().start();
 */
export declare class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {
    readonly name: string;
    /**
     *  The oscillator's frequency
     */
    readonly frequency: Signal<Frequency>;
    /**
     *  The detune control signal.
     */
    readonly detune: Signal<Cents>;
    /**
     *  The array of oscillators
     */
    private _oscillators;
    /**
     *  The total spread of the oscillators
     */
    private _spread;
    /**
     *  The type of the oscillator
     */
    private _type;
    /**
     *  The phase of the oscillators
     */
    private _phase;
    /**
     *  The partials array
     */
    private _partials;
    /**
     *  The number of partials to use
     */
    private _partialCount;
    constructor(options?: Partial<FatConstructorOptions>);
    constructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);
    static getDefaults(): FatOscillatorOptions;
    /**
     *  start the oscillator
     */
    protected _start(time: Time): void;
    /**
     *  stop the oscillator
     */
    protected _stop(time: Time): void;
    /**
     *  restart the oscillator
     */
    restart(time: any): this;
    /**
     *  Iterate over all of the oscillators
     */
    private _forEach;
    /**
     * The type of the oscillator
     */
    type: ToneOscillatorType;
    /**
     * The detune spread between the oscillators. If "count" is
     * set to 3 oscillators and the "spread" is set to 40,
     * the three oscillators would be detuned like this: [-20, 0, 20]
     * for a total detune spread of 40 cents.
     */
    spread: Cents;
    /**
     * The number of detuned oscillators. Should be an integer greater than 1.
     */
    count: number;
    /**
     * The phase of the oscillator in degrees.
     */
    phase: Degrees;
    /**
     * The oscillator type without the partialsCount appended to the end
     * @example
     * osc.type = 'sine2'
     * osc.baseType //'sine'
     * osc.partialCount = 2
     */
    baseType: OscillatorType;
    /**
     * The partials of the carrier waveform. A partial represents
     * the amplitude at a harmonic. The first harmonic is the
     * fundamental frequency, the second is the octave and so on
     * following the harmonic series.
     * Setting this value will automatically set the type to "custom".
     * The value is an empty array when the type is not "custom".
     * @memberOf FatOscillator#
     * @type {Array}
     * @name partials
     * @example
     * osc.partials = [1, 0.2, 0.01];
     */
    partials: number[];
    /**
     * 'partialCount' offers an alternative way to set the number of used partials.
     * When partialCount is 0, the maximum number of partials are used when representing
     * the waveform using the periodicWave. When 'partials' is set, this value is
     * not settable, but equals the length of the partials array.
     * @memberOf FatOscillator#
     * @type {Number}
     * @name partialCount
     */
    partialCount: number;
    /**
     *  Clean up.
     */
    dispose(): this;
}
