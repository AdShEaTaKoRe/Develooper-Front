import { AbstractParam } from "../core/context/AbstractParam";
import { Param } from "../core/context/Param";
import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from "../core/context/ToneAudioNode";
import { Time, Unit, UnitName } from "../core/type/Units";
import { ToneConstantSource } from "./ToneConstantSource";
export interface SignalOptions<Type> extends ToneAudioNodeOptions {
    value: Type;
    units: UnitName;
    convert: boolean;
}
/**
 * A signal is an audio-rate value. Tone.Signal is a core component of the library.
 * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal
 * has all of the methods available to native Web Audio
 * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)
 * as well as additional conveniences. Read more about working with signals
 * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).
 *
 * @example
 * const signal = new Tone.Signal(10);
 */
export declare class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>> implements AbstractParam<Type> {
    readonly name: string;
    /**
     * Indicates if the value should be overridden on connection.
     */
    readonly override: boolean;
    /**
     * The constant source node which generates the signal
     */
    protected _constantSource: ToneConstantSource<Type>;
    readonly output: OutputNode;
    protected _param: Param<Type>;
    readonly input: InputNode;
    /**
     * @param value Initial value of the signal
     * @param units The unit name, e.g. "frequency"
     */
    constructor(value?: Type, units?: UnitName);
    constructor(options?: Partial<SignalOptions<Type>>);
    static getDefaults(): SignalOptions<any>;
    connect(destination: InputNode, outputNum?: number, inputNum?: number): this;
    dispose(): this;
    setValueAtTime(value: Type, time: Time): this;
    getValueAtTime(time: Time): Type;
    setRampPoint(time: Time): this;
    linearRampToValueAtTime(value: Type, time: Time): this;
    exponentialRampToValueAtTime(value: Type, time: Time): this;
    exponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this;
    linearRampTo(value: Type, rampTime: Time, startTime?: Time): this;
    targetRampTo(value: Type, rampTime: Time, startTime?: Time): this;
    exponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this;
    setTargetAtTime(value: Type, startTime: Time, timeConstant: number): this;
    setValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this;
    cancelScheduledValues(time: Time): this;
    cancelAndHoldAtTime(time: Time): this;
    rampTo(value: Type, rampTime: Time, startTime?: Time): this;
    value: Type;
    convert: boolean;
    readonly units: UnitName;
    overridden: boolean;
    readonly maxValue: number;
    readonly minValue: number;
    /**
     * See [[Param.apply]].
     */
    apply(param: Param | AudioParam): this;
}
/**
 * When connecting from a signal, it's necessary to zero out the node destination
 * node if that node is also a signal. If the destination is not 0, then the values
 * will be summed. This method insures that the output of the destination signal will
 * be the same as the source signal, making the destination signal a pass through node.
 * @param signal The output signal to connect from
 * @param destination the destination to connect to
 * @param outputNum the optional output number
 * @param inputNum the input number
 */
export declare function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void;
