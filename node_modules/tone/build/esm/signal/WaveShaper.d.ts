import { ToneAudioNodeOptions } from "../core/context/ToneAudioNode";
import { SignalOperator } from "./SignalOperator";
declare type WaveShaperMappingFn = (value: number, index?: number) => number;
declare type WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;
interface WaveShaperOptions extends ToneAudioNodeOptions {
    mapping?: WaveShaperMapping;
    length: number;
    curve?: number[] | Float32Array;
}
/**
 * Wraps the native Web Audio API
 * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).
 *
 * @example
 * var timesTwo = new WaveShaper(function(val){
 * 	return val * 2;
 * }, 2048);
 * @example
 * //a waveshaper can also be constructed with an array of values
 * var invert = new WaveShaper([1, -1]);
 */
export declare class WaveShaper extends SignalOperator<WaveShaperOptions> {
    readonly name: string;
    /**
     *  the waveshaper node
     */
    private _shaper;
    /**
     * The input to the waveshaper node.
     */
    input: WaveShaperNode;
    /**
     * The output from the waveshaper node
     */
    output: WaveShaperNode;
    /**
     * @param mapping The function used to define the values.
     *                 The mapping function should take two arguments:
     *                 the first is the value at the current position
     *                 and the second is the array position.
     *                 If the argument is an array, that array will be
     *                 set as the wave shaping function. The input
     *                 signal is an AudioRange [-1, 1] value and the output
     *                 signal can take on any numerical values.
     *
     * @param bufferLen The length of the WaveShaperNode buffer.
     */
    constructor(mapping?: WaveShaperMapping, length?: number);
    constructor(options?: Partial<WaveShaperOptions>);
    static getDefaults(): WaveShaperOptions;
    /**
     *  Uses a mapping function to set the value of the curve.
     * @param mapping The function used to define the values.
     *                 The mapping function take two arguments:
     *                 the first is the value at the current position
     *                 which goes from -1 to 1 over the number of elements
     *                 in the curve array. The second argument is the array position.
     * @example
     * //map the input signal from [-1, 1] to [0, 10]
     * shaper.setMap(function(val, index){
     * 	return (val + 1) * 5;
     * })
     */
    setMap(mapping: WaveShaperMappingFn, length?: number): this;
    /**
     * The array to set as the waveshaper curve. For linear curves
     * array length does not make much difference, but for complex curves
     * longer arrays will provide smoother interpolation.
     */
    curve: Float32Array | null;
    /**
     * Specifies what type of oversampling (if any) should be used when
     * applying the shaping curve. Can either be "none", "2x" or "4x".
     */
    oversample: OverSampleType;
    /**
     *  Clean up.
     */
    dispose(): this;
}
export {};
