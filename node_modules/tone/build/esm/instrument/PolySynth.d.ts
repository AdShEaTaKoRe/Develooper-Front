import { Frequency, NormalRange, Time } from "../core/type/Units";
import { RecursivePartial } from "../core/util/Interface";
import { Instrument, InstrumentOptions } from "./Instrument";
import { MembraneSynth, MembraneSynthOptions } from "./MembraneSynth";
import { MetalSynth, MetalSynthOptions } from "./MetalSynth";
import { Monophonic } from "./Monophonic";
import { Synth, SynthOptions } from "./Synth";
declare type VoiceConstructor<V> = {
    getDefaults: () => VoiceOptions<V>;
} & (new (...args: any[]) => V);
declare type OmitMonophonicOptions<T> = Omit<T, "context" | "onsilence">;
declare type VoiceOptions<T> = T extends MembraneSynth ? MembraneSynthOptions : T extends MetalSynth ? MetalSynthOptions : T extends Synth ? SynthOptions : never;
/**
 * The settable synth options. excludes monophonic options.
 */
declare type PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;
export interface PolySynthOptions<Voice> extends InstrumentOptions {
    maxPolyphony: number;
    voice: VoiceConstructor<Voice>;
    options: PartialVoiceOptions<Voice>;
}
/**
 * PolySynth handles voice creation and allocation for any
 * instruments passed in as the second paramter. PolySynth is
 * not a synthesizer by itself, it merely manages voices of
 * one of the other types of synths, allowing any of the
 * monophonic synthesizers to be polyphonic.
 *
 * @example
 * var synth = new PolySynth(Tone.Synth, {
 *   oscillator : {
 * 		type : "square"
 * 	}
 * }).toMaster();
 * //set the attributes using the set interface
 * synth.set("detune", -1200);
 * //play a chord
 * synth.triggerAttackRelease(["C4", "E4", "A4"], "4n");
 */
export declare class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {
    readonly name: string;
    /**
     * The voices which are not currently in use
     */
    private _availableVoices;
    /**
     * The currently active voices
     */
    private _activeVoices;
    /**
     * All of the allocated voices for this synth.
     */
    private _voices;
    /**
     * The options that are set on the synth.
     */
    private options;
    /**
     * The polyphony limit.
     */
    maxPolyphony: number;
    /**
     * The voice constructor
     */
    private readonly voice;
    /**
     * The GC timeout. Held so that it could be cancelled when the node is disposed.
     */
    private _gcTimeout;
    /**
     * A moving average of the number of active voices
     */
    private _averageActiveVoices;
    /**
     * @param voice The constructor of the voices
     * @param options	The options object to set the synth voice
     */
    constructor(voice?: VoiceConstructor<Voice>, options?: PartialVoiceOptions<Voice>);
    constructor(options?: Partial<PolySynthOptions<Voice>>);
    static getDefaults(): PolySynthOptions<Synth>;
    /**
     * The number of active voices.
     */
    readonly activeVoices: number;
    /**
     * If there is a voice active on that note, return it
     */
    private _getActiveVoice;
    /**
     * Invoked when the source is done making sound, so that it can be
     * readded to the pool of available voices
     */
    private _makeVoiceAvailable;
    /**
     * Get an available voice from the pool of available voices.
     * If one is not available and the maxPolyphony limit is reached,
     * steal a voice, otherwise return null.
     */
    private _getNextAvailableVoice;
    /**
     * Occasionally check if there are any allocated voices which can be cleaned up.
     */
    private _collectGarbage;
    /**
     * Internal method which triggers the attack
     */
    private _triggerAttack;
    /**
     * Internal method which triggers the release
     */
    private _triggerRelease;
    /**
     * Schedule the attack/release events. If the time is in the future, then it should set a timeout
     * to wait for just-in-time scheduling
     */
    private _scheduleEvent;
    /**
     * Trigger the attack portion of the note
     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
     * @param  time  The start time of the note.
     * @param velocity The velocity of the note.
     * @example
     * //trigger a chord immediately with a velocity of 0.2
     * poly.triggerAttack(["Ab3", "C4", "F5"], undefined, 0.2);
     */
    triggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this;
    /**
     * Trigger the release of the note. Unlike monophonic instruments,
     * a note (or array of notes) needs to be passed in as the first argument.
     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.
     * @param  time  When the release will be triggered.
     * @example
     * poly.triggerRelease(["Ab3", "C4", "F5"], "+2n");
     */
    triggerRelease(notes: Frequency | Frequency[], time?: Time): this;
    /**
     * Trigger the attack and release after the specified duration
     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.
     * @param  duration the duration of the note
     * @param  time  if no time is given, defaults to now
     * @param  velocity the velocity of the attack (0-1)
     * @example
     * //trigger a chord for a duration of a half note
     * poly.triggerAttackRelease(["Eb3", "G4", "C5"], "2n");
     * @example
     * //can pass in an array of durations as well
     * poly.triggerAttackRelease(["Eb3", "G4", "C5"], ["2n", "4n", "4n"]);
     */
    triggerAttackRelease(notes: Frequency | Frequency[], duration: Time | Time[], time?: Time, velocity?: NormalRange): this;
    /**
     * Sync the instrument to the Transport. All subsequent calls of
     * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.
     * @example
     * synth.sync()
     * //schedule 3 notes when the transport first starts
     * synth.triggerAttackRelease('8n', 0)
     * synth.triggerAttackRelease('8n', '8n')
     * synth.triggerAttackRelease('8n', '4n')
     * //start the transport to hear the notes
     * Transport.start()
     */
    sync(): this;
    /**
     * Set a member/attribute of the voices
     * @example
     * poly.set({
     * 	"filter" : {
     * 		"type" : "highpass"
     * 	},
     * 	"envelope" : {
     * 		"attack" : 0.25
     * 	}
     * });
     */
    set(options: RecursivePartial<VoiceOptions<Voice>>): this;
    /**
     *  Get the synth's attributes.
     */
    get(): VoiceOptions<Voice>;
    /**
     * Trigger the release portion of all the currently active voices immediately.
     * Useful for silencing the synth.
     */
    releaseAll(): this;
    dispose(): this;
}
export {};
